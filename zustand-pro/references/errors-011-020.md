# Common Errors & Fixes (ZST-011 to ZST-020)

## ZST-011: "Cannot read properties of undefined" on Store Access

**Error:**
```
TypeError: Cannot read properties of undefined (reading 'getState')
```

**Cause:** Using context-based store (`createStore` + `useContext`) without wrapping in Provider.

**Fix:** Ensure the Provider wraps the component tree:
```tsx
// In layout.tsx or page.tsx:
<CVStoreProvider initialData={data}>
  <CVEditor />   {/* Can now use useCVStore() */}
</CVStoreProvider>
```

---

## ZST-012: Immer Middleware Not Working (State Not Updating)

**Error:** Mutations inside `set()` don't produce new state.

**Cause:** Forgot to import `immer` from the correct path.

**Fix:**
```typescript
// WRONG:
import { immer } from 'zustand/middleware'

// CORRECT:
import { immer } from 'zustand/middleware/immer'
```

Also, with immer, do NOT return anything from `set()`:

```typescript
// WRONG with immer:
set((state) => {
  state.count += 1
  return state      // DO NOT return -- immer handles it
})

// CORRECT with immer:
set((state) => {
  state.count += 1  // Just mutate, don't return
})
```

---

## ZST-013: Multiple Store Instances in Dev (Fast Refresh)

**Error:** State resets or behaves oddly during development hot reload.

**Cause:** Next.js Fast Refresh re-executes module, creating a new store instance.

**Fix:** This is expected in development. For persist stores, the state is restored from storage. For non-persist stores, this is the intended behavior (fresh state on code change).

If you need state preservation during dev:
```typescript
// Use persist middleware even in dev
const useStore = create(
  persist(
    (set) => ({ /* ... */ }),
    {
      name: 'dev-store',
      storage: createJSONStorage(() => sessionStorage), // Use session for dev
    }
  )
)
```

---

## ZST-014: TypeScript Error with Slices + Middleware

**Error:**
```
Type 'StateCreator<CombinedState, [["zustand/devtools", never]]>' is not assignable...
```

**Cause:** Slice creators need to know about middleware mutators.

**Fix:**
```typescript
import type { StateCreator } from 'zustand'

// Declare middleware mutators
type Middleware = [['zustand/devtools', never], ['zustand/immer', never]]

const createPersonalSlice: StateCreator<
  CombinedState,   // Full state
  Middleware,       // Middleware mutators
  [],               // Additional mutators
  PersonalSlice     // This slice
> = (set) => ({
  // ...
})
```

---

## ZST-015: Persist + Immer Deep Merge Conflict

**Error:** Nested objects in persisted state lose reactivity or don't update correctly.

**Cause:** Persist's shallow merge conflicts with Immer's proxy mechanism.

**Fix:** Use a custom `merge` function:
```typescript
persist(
  immer((set) => ({
    nested: { a: 1, b: { c: 2 } },
    // ...
  })),
  {
    name: 'deep-store',
    merge: (persisted, current) => {
      // Deep merge using structuredClone or a library
      return structuredClone({ ...current, ...(persisted as any) })
    },
  }
)
```

---

## ZST-016: React Compiler Warning About Non-`use`-Prefixed Store

**Warning:**
```
React Compiler: Hooks must be called with a `use` prefix
```

**Cause:** React 19 Compiler requires hooks to follow naming conventions. A Zustand store named `store` or `bearStore` without `use` prefix will trigger this.

**Fix:** Always name stores with the `use` prefix:
```typescript
// WRONG:
const bearStore = create(/* ... */)
const store = create(/* ... */)

// CORRECT:
const useBearStore = create(/* ... */)
const useCVEditorStore = create(/* ... */)
```

---

## ZST-017: `subscribeWithSelector` Fires on Every Update

**Error:** Subscription callback triggers even when the selected state hasn't changed.

**Cause:** Selector returns a new reference on every call (e.g., array/object creation).

**Fix:** Use a stable selector or provide an equality function:
```typescript
// With equality function:
useStore.subscribe(
  (state) => ({ a: state.a, b: state.b }),
  (selected, prev) => { /* ... */ },
  { equalityFn: shallow }
)

// Or use a stable selector:
const selectCount = (state: State) => state.count
useStore.subscribe(selectCount, (count, prev) => { /* ... */ })
```

---

## ZST-018: `setState` Replace Mode Missing Fields (v5)

**Error:**
```
Argument of type '{ count: number; }' is not assignable to parameter of type 'State'.
Property 'increment' is missing in type...
```

**Cause:** In v5, `setState(partialState, true)` (replace mode) requires ALL fields.

**Fix:**
```typescript
// In v5, replace mode needs complete state:
store.setState(
  {
    count: 0,
    increment: store.getState().increment,
    decrement: store.getState().decrement,
  },
  true
)

// Or use partial update (no replace):
store.setState({ count: 0 })
```

---

## ZST-019: "window is not defined" During Build

**Error:**
```
ReferenceError: window is not defined
```

**Cause:** Store with persist middleware imported in a file that runs during SSR/build.

**Fix:** Guard window access:
```typescript
const useStore = create(
  persist(
    (set) => ({ /* ... */ }),
    {
      name: 'my-store',
      storage: createJSONStorage(() =>
        typeof window !== 'undefined' ? localStorage : ({
          getItem: () => null,
          setItem: () => {},
          removeItem: () => {},
        } as Storage)
      ),
    }
  )
)
```

---

## ZST-020: Stale Closure in useEffect with Zustand State

**Error:** `useEffect` callback reads stale store values.

**Cause:** The effect captures the initial selector value and doesn't update.

**Fix -- Use `subscribe` inside useEffect:**
```typescript
useEffect(() => {
  // Subscribe to changes outside React render
  const unsub = useMyStore.subscribe(
    (state) => state.someValue,
    (value) => {
      // Always has the latest value
      doSomethingWith(value)
    }
  )
  return unsub
}, [])
```

**Fix -- Use `getState()` for one-time reads:**
```typescript
useEffect(() => {
  const currentValue = useMyStore.getState().someValue
  doSomethingWith(currentValue)
}, [trigger])
```
