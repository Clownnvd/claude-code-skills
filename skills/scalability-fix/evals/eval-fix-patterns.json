{
  "skill": "scalability-fix",
  "eval_name": "eval-fix-patterns",
  "description": "Verify specific fix patterns from references/fix-patterns/ produce correct code changes for scalability issues.",
  "tests": [
    {
      "id": "dynamic-import-heavy-libraries",
      "name": "Dynamic Import Heavy Libraries (bundle-images.md)",
      "prompt": "Apply Dynamic Import pattern to lazy-load heavy browser-only libraries",
      "setup": "`chart.js` imported at top level in a dashboard component, adding 200KB to initial bundle.",
      "input_files": [],
      "expectations": [
        "Apply Dynamic Import pattern",
        "Verify top-level `import { Chart } from 'chart.js'` replaced with `next/dynamic`",
        "Verify `{ ssr: false }` set for browser-only libraries",
        "Verify `pnpm build` shows reduced First Load JS for the page"
      ],
      "pass_criteria": "Chart component lazy-loaded. Initial bundle does not include chart.js. Component renders after hydration with loading state.",
      "fail_indicators": [
        "Top-level import remains, or `ssr: false` missing for browser-only lib, or bundle size unchanged"
      ]
    },
    {
      "id": "extract-client-interactivity",
      "name": "Extract Client Interactivity (rsc-dbperf.md)",
      "prompt": "Apply Extract Client Interactivity pattern to isolate interactive elements into leaf client components",
      "setup": "Entire product page has `\"use client\"` because one button uses `useState`. Static content (headings, descriptions) shipped as client JS.",
      "input_files": [],
      "expectations": [
        "Apply Extract Client Interactivity pattern",
        "Verify button extracted to separate `\"use client\"` component",
        "Verify page component is now a Server Component (no directive)",
        "Verify static content rendered server-side"
      ],
      "pass_criteria": "Only interactive button is a client component. Page is server-rendered. `pnpm build` shows reduced client JS for the route.",
      "fail_indicators": [
        "Page still has `\"use client\"`, or extraction breaks event handling"
      ]
    },
    {
      "id": "promise-all-for-parallel-fetches",
      "name": "Promise.all for Parallel Fetches (concurrency-monitoring.md)",
      "prompt": "Apply Promise.all pattern to parallelize independent sequential queries",
      "setup": "Layout fetches user, preferences, and history sequentially. Total waterfall time is sum of all three queries.",
      "input_files": [],
      "expectations": [
        "Apply Promise.all pattern",
        "Verify sequential `await` calls replaced with `Promise.all([...])`",
        "Verify destructuring matches original variable names",
        "Verify independent queries identified correctly (no data dependency between them)"
      ],
      "pass_criteria": "Three queries run in parallel. Total time equals slowest query, not sum. Error in one query propagates correctly. Dependent queries (where output of A feeds into B) kept sequential.",
      "fail_indicators": [
        "Still sequential, or dependent queries incorrectly parallelized"
      ]
    },
    {
      "id": "bounded-in-memory-cache",
      "name": "Bounded In-Memory Cache (edge-memory.md)",
      "prompt": "Apply Bounded Cache pattern to replace unbounded Map with size-limited TTL cache",
      "setup": "Rate limiter uses unbounded `new Map()` that grows indefinitely in long-running processes.",
      "input_files": [],
      "expectations": [
        "Apply Bounded Cache pattern",
        "Verify `BoundedCache` class with `maxSize` and `ttlMs` parameters",
        "Verify eviction of oldest entry when `maxSize` reached",
        "Verify expired entries return `undefined` on `get()`"
      ],
      "pass_criteria": "Cache has configurable max size (e.g., 10000 entries). Entries expire after TTL. Old entries evicted when full. Rate limiter uses bounded cache instead of raw Map.",
      "fail_indicators": [
        "No size limit, or no TTL expiry, or eviction breaks rate limiting logic"
      ]
    }
  ]
}
